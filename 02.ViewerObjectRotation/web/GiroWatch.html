<html>

<head>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=no" />
    <meta charset="utf-8">

    <!-- The Viewer CSS -->


    <!-- The Viewer JS -->
    <script src="https://developer.api.autodesk.com/derivativeservice/v2/viewers/three.min.js"></script>
    <script src="https://developer.api.autodesk.com/derivativeservice/v2/viewers/viewer3D.min.js"></script>
    <script src="./assets/js/dat.gui.js"></script>

    <link rel="stylesheet" href="https://developer.api.autodesk.com/derivativeservice/v2/viewers/style.min.css" type="text/css">

    <!-- Developer CSS -->
    <link rel="stylesheet" href="./assets/css/my_style.css" type="text/css">
    <link rel="stylesheet" href="./assets/css/light_dat.css" type="text/css">
    <style>
        #MyControls {
            position: absolute;
            top: 5px;
            left: 5px;
            z-index: 1;
            /* padding: 1em; */
            /* font-size: 1em; */
            /* cursor: pointer; */
            /* box-shadow: 5px 5px 5px #888888; */
            /* border: 1px solid gray; */
            /* border-radius: 5px; */
        }
    </style>

</head>

<body>

    <!-- The Viewer will be instantiated here -->
    <div id="MyViewerDiv"></div>
    <div id="MyControls" class="adsk control">
        <p style="text-align: center;">Giro Controls</p>
        <!-- <input type="range">Main Axis</input> -->
    </div>

    <script>
        let MyControls = function () {
            this.mainAngle = 0;
        }


        // window.onload = function () {
        //     let giro_control = new MyControls();
        //     let gui = new dat.GUI({ autoPlace: false });
        //     document.getElementById("MyControls").append(gui.domElement);
        //     gui.add(giro_control, 'mainAngle', 0, 360);
        // }
    </script>



    <!-- Developer JS -->
    <script src="./assets/js/auxiliary.js"></script>
    <script>
        var viewerApp;
        let viewer = null;
        let tree = null;
        var options = {
            env: 'AutodeskProduction',
            getAccessToken: function (onGetAccessToken) {
                var token_fetcher = 'https://9irt90dm6j.execute-api.us-east-1.amazonaws.com/prod'
                var xmlHttp = new XMLHttpRequest();
                xmlHttp.open("GET", token_fetcher, false);
                xmlHttp.send(null);
                var data = JSON.parse(xmlHttp.responseText);

                var accessToken = data["access_token"]
                var expireTimeSeconds = data["expires_in"];
                onGetAccessToken(accessToken, expireTimeSeconds);
            }

        };
        var documentId = 'urn:dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6Y2xvY2tfcmVwby8wMUdpcm9XYXRjaC5mM2Q';
        Autodesk.Viewing.Initializer(options, function onInitialized() {
            viewerApp = new Autodesk.Viewing.ViewingApplication('MyViewerDiv');
            viewerApp.registerViewer(viewerApp.k3D, Autodesk.Viewing.Viewer3D);
            viewerApp.loadDocument(documentId, onDocumentLoadSuccess, onDocumentLoadFailure);
            viewer = viewerApp.getCurrentViewer();
        });

        function onDocumentLoadSuccess(doc) {

            // We could still make use of Document.getSubItemsWithProperties()
            // However, when using a ViewingApplication, we have access to the **bubble** attribute,
            // which references the root node of a graph that wraps each object from the Manifest JSON.
            var viewables = viewerApp.bubble.search({ 'type': 'geometry' });
            if (viewables.length === 0) {
                console.error('Document contains no viewables.');
                return;
            }

            // Choose any of the avialble viewables
            viewerApp.selectItem(viewables[0].data, onItemLoadSuccess, onItemLoadFail);


        }

        function onDocumentLoadFailure(viewerErrorCode) {
            console.error('onDocumentLoadFailure() - errorCode:' + viewerErrorCode);
        }

        function onItemLoadSuccess(reported_viewer, item) {

            viewer = reported_viewer;
            viewer.addEventListener(Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT, setupMyModel);
        }

        function onItemLoadFail(errorCode) {
            console.error('onItemLoadFail() - errorCode:' + errorCode); 
        }



        function setupMyModel() {
            /*============================ MY ATTEMPTS =======================*/

            tree = viewer.model.getData().instanceTree;


            let pin_Id = findNodeIdbyName('Pin');
            let secondsArm_Id = findNodeIdbyName('SecondsArm');
            let minuteArm_Id = findNodeIdbyName('MinuteArm');
            let hourArm_Id = findNodeIdbyName('HourArm');



            class Jointer {
                constructor(NodeId) {
                    this.parent = null;
                    this.childrens = new Array();
                    this.helper = new THREE.Mesh();
                    this.node_id = NodeId;
                    let fragment_position = getFragmentWorldMatrixByNodeId(this.node_id).matrix[0].getPosition().clone();
                    this.helper.position.x = fragment_position.x;
                    this.helper.position.y = fragment_position.y;
                    this.helper.position.z = fragment_position.z;
                }

                getPosition() {
                    return new THREE.Vector3(this.helper.position.x, this.helper.position.y, this.helper.position.z);
                }

                getRotation() {
                    return this.helper.rotation.clone();
                }

                setRotationX(valueX) {
                    this.helper.rotation.x = valueX;
                }

                getReference() {
                    return this.helper;
                }

                setParent(parentJointer) {

                    this.parent = parentJointer;
                    this.helper.position.x = -this.helper.position.x + Math.abs(this.helper.position.x - this.parent.getPosition().x);
                    this.helper.position.y = -this.helper.position.y + Math.abs(this.helper.position.y - this.parent.getPosition().y);
                    this.helper.position.z = this.helper.position.z + Math.abs(this.helper.position.z + this.parent.getPosition().z);
                    this.parent.getReference().add(this.helper);
                }

                addToScene() {
                    if (viewer) {
                        viewer.impl.scene.add(this.helper);
                    }
                }

                addChild(childJointer) {
                    this.childrens.push(childJointer);
                    this.childrens[this.childrens.length - 1].setParent(this);
                }

                updateTransformation() {
                    if (this.parent) {
                        this.parent.helper.updateMatrixWorld();
                        var position = new THREE.Vector3();
                        var rotation = new THREE.Quaternion();
                        var scale = new THREE.Vector3();
                        this.helper.matrixWorld.decompose(position, rotation, scale);
                        tree.enumNodeFragments(this.node_id, function (frag) {
                            var fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);
                            fragProxy.getAnimTransform();
                            fragProxy.position = position;
                            fragProxy.quaternion = rotation;
                            fragProxy.updateAnimTransform();
                        })

                    }

                    this.childrens.forEach(function (element) {
                        element.updateTransformation();
                    }, this);
                }
            }


            /* ====================== SECONDS ================= */
            let seconds_pivot = new Jointer(pin_Id);
            seconds_pivot.addToScene();
            let seconds_helper = new Jointer(secondsArm_Id);
            seconds_pivot.addChild(seconds_helper);


            /* ====================== MINUTES ================= */
            let minute_pivot = new Jointer(pin_Id);
            minute_pivot.addToScene();
            let minute_helper = new Jointer(minuteArm_Id);
            minute_pivot.addChild(minute_helper);


            // /* ====================== HOURS ================= */
            let hour_pivot = new Jointer(pin_Id);
            hour_pivot.addToScene();
            let hour_helper = new Jointer(hourArm_Id);
            hour_pivot.addChild(hour_helper);



            setInterval(function () {
                var timing = new Date();

                // hour_pivot.rotation.x = -1 * timing.getHours() * 2 * Math.PI / 12 + minute_pivot.rotation.x / 12;

                seconds_pivot.setRotationX(-1 * timing.getSeconds() * 2 * Math.PI / 60);
                seconds_pivot.updateTransformation();

                minute_pivot.setRotationX(-1 * timing.getMinutes() * 2 * Math.PI / 60);
                minute_pivot.updateTransformation();

                hour_pivot.setRotationX(-1 * timing.getHours() * 2 * Math.PI / 12 + minute_pivot.getRotation().x / 12);
                hour_pivot.updateTransformation();

                viewer.impl.sceneUpdated();

            }, 1000);

        }


            /*============================ END OF MY ATTEMPTS =======================*/
    </script>





</body>

</html>