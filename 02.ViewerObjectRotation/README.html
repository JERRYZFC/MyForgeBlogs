<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>README.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}@import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:"Roboto Condensed",Tauri,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;background-color:rgba(0,0,0,.02);padding:.2em .5em;border:1px solid #efefef}.haroopad pre>code{font-size:1em;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">
<h1 id="know-how:-complex-component-transformations-in-viewer---part-1-(basics)"><a name="know-how:-complex-component-transformations-in-viewer---part-1-(basics)" href="#know-how:-complex-component-transformations-in-viewer---part-1-(basics)"></a>Know-How: Complex component transformations in Viewer - Part 1 (Basics)</h1><p>In some of our previous blog posts we touched the idea of component translation and rotation. More complex transformations, like rotation of one component around another one, are usually accompanied by frustration with translation/rotation matrices, matrix inverses, quaternions and other fun stuff that rapidly gets out of hand in case of more complex hierarchical transformations. </p><p>In this 2 parts post, I will present another approach:</p><p>In the first part of this tutorial, I will explain the basics of the proposed approach along with an illustration on a very simple model. You can see the expected result <a href="http://sample-collection.s3-website-us-east-1.amazonaws.com/WoodenWatch.html">here</a>.</p><p>In the second part, I will present how this approach can be applied for more complex transformations and all that will be illustrated on a more complex model. The expected result can be observed <a href="http://sample-collection.s3-website-us-east-1.amazonaws.com/GiroWatch.html">here</a>.</p><p>To illustrate the proposed approach, I will start with a fairly simple model of desk clock:</p><p><img src="doc/img/01_main.png" alt=""></p><p>and you can see that the hours, minutes and seconds arms of the clock are grouped at 12 o’clock and fail to expose the beauty or ugliness of their design and their integration in the overall design.</p><p>Wouldn’t be wonderful to have this model display the current time right in the Viewer? An excellent requirement for an online clock shop using the Viewer for illustration of available beauties.</p><p>After briefly examining the model, we can see that the task of showing the current time can be translated as “rotate <em>HourArm</em>, <em>MinuteArm</em> and <em>SecondsArm</em> components around <em>pin</em> component (based on some data, but this is not important now).</p><p>Based on experience of previous blog posts and some samples, the course of actions would be the following:</p><ol>
<li><p>Get the NodeId of needed component:</p>
<p> The NodeId of a needed component can be found by selecting that component and calling the <code>viewer.getSelection()</code> in the console, but for our purpose, based on knowledge from <a href="https://forge.autodesk.com/cloud_and_mobile/2016/10/get-all-database-ids-in-the-model.html">Get all database id’s in the model</a> post, this could be achieved be creating a helper function like this:</p>
<pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;> function findNodeIdbyName(name) {
     let nodeList = Object.values(tree.nodeAccess.dbIdToIndex);
     for (let i = 0, len = nodeList.length; i &amp;lt; len; ++i) {
         if (tree.getNodeName(nodeList[i]) === name) {
             return nodeList[i];
         }
     }
     return null;
 }
</code></pre>"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findNodeIdbyName</span><span class="hljs-params">(name)</span> </span>{
     <span class="hljs-keyword">let</span> nodeList = <span class="hljs-built_in">Object</span>.values(tree.nodeAccess.dbIdToIndex);
     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = nodeList.length; i &lt; len; ++i) {
         <span class="hljs-keyword">if</span> (tree.getNodeName(nodeList[i]) === name) {
             <span class="hljs-keyword">return</span> nodeList[i];
         }
     }
     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
 }
</code></pre>
</li><li><p>Get the fragments and fragment proxy corresponding to a node:</p>
<p> This is usually achieved with a following code:</p>
<pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;>
 let tree = viewer.model.getData().instanceTree

 tree.enumNodeFragments(nodeId, function (frag) {
     let fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);

     //do some work with fragment proxy

 });
</code></pre>">
 <span class="hljs-keyword">let</span> tree = viewer.model.getData().instanceTree

 tree.enumNodeFragments(nodeId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(frag)</span> </span>{
     <span class="hljs-keyword">let</span> fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);

     <span class="hljs-comment">//do some work with fragment proxy</span>

 });
</code></pre>
</li><li><p>Get transforms for each fragment proxy, modify them and “commit” the changes:</p>
<pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;> ...
 fragProxy.getAnimTransform();
 fragProxy.position = some_new_position;
 fragProxy.quaternion = some_new_rotation;
 fragProxy.updateAnimTransform();
 ...
</code></pre>"> ...
 fragProxy.getAnimTransform();
 fragProxy.position = some_new_position;
 fragProxy.quaternion = some_new_rotation;
 fragProxy.updateAnimTransform();
 ...
</code></pre>
</li><li><p>Update the scene, by calling <code>viewer.impl.sceneUpdated(true);</code></p>
</li></ol><p>Thus, for our example, to rotate (around X axis) the <em>SecondsArm</em>, the code would look something like:</p><pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;>let secondsArm_Id = findNodeIdbyName('SecondsArm');
let tree = viewer.model.getData().instanceTree;

tree.enumNodeFragments(secondsArm_Id, function (frag) {
    var fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);
    fragProxy.getAnimTransform();
    fragProxy.quaternion = new THREE.Quaternion().setFromAxisAngle(
                                    new THREE.Vector3(1,0,0), 
                                    -Math.PI/2);
    fragProxy.updateAnimTransform();
});

viewer.impl.sceneUpdated(true);
</code></pre>"><span class="hljs-keyword">let</span> secondsArm_Id = findNodeIdbyName(<span class="hljs-string">'SecondsArm'</span>);
<span class="hljs-keyword">let</span> tree = viewer.model.getData().instanceTree;

tree.enumNodeFragments(secondsArm_Id, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(frag)</span> </span>{
    <span class="hljs-keyword">var</span> fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);
    fragProxy.getAnimTransform();
    fragProxy.quaternion = <span class="hljs-keyword">new</span> THREE.Quaternion().setFromAxisAngle(
                                    <span class="hljs-keyword">new</span> THREE.Vector3(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), 
                                    -<span class="hljs-built_in">Math</span>.PI/<span class="hljs-number">2</span>);
    fragProxy.updateAnimTransform();
});

viewer.impl.sceneUpdated(<span class="hljs-literal">true</span>);
</code></pre><p>Thus, the result of strightforward (90 degrees) rotation of the <em>SecondsArm</em> will result in something like this:</p><p><img src="doc/img/02_rotation.png" alt=""></p><p>As you can see, component rotation is not a big deal, but the problem is that the rotation is around its “gravity center”, while we would like to rotate it around another axis, and in our example we are lucky that it is just around X axis, at <em>pin</em> coordinates.</p><p>In this case, any self respecting book on computer graphics will tell you that it is basically calculation of its new translation and rotation, and this is where the fun with translation matrix, rotation matrix and inverses come into play and the natural course of action is to abstract all this and come up with a system.</p><p>The funny thing is that sooner or later you’ll realize that you are building your <a href="http://www.imdb.com/title/tt0756891/quotes">“ … own theme park, with blackjack and …”</a>, while all this already exists in three.js library upon which Autodesk Viewer is based.</p><p>It is true, that your model is not integrated into three.js scene as you might expect, but this doesn’t mean that we cannot use indirectly it’s “logic”.</p><p>To better illustrate my point, let us start with a fairly simple three.js example, based on <a href="https://threejs.org/docs/#manual/introduction/Creating-a-scene">Three.js getting Started project</a>:</p><p><img src="doc/img/independent_rotation.gif" alt=""></p><p>In this very example both cubes were added to the scene (to the root node), the red one right in “the center of the Universe”, while the blue one somewhere in the world:</p><pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;>...

scene.add(red_cube);
scene.add(blue_cube);

camera.position.z = 5;
blue_cube.position.x = 2;

var animate = function () {
    requestAnimationFrame(animate);

    red_cube.rotation.z += 0.01;

    renderer.render(scene, camera); 
};

...
</code></pre>">...

scene.add(red_cube);
scene.add(blue_cube);

camera.position.z = <span class="hljs-number">5</span>;
blue_cube.position.x = <span class="hljs-number">2</span>;

<span class="hljs-keyword">var</span> animate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    requestAnimationFrame(animate);

    red_cube.rotation.z += <span class="hljs-number">0.01</span>;

    renderer.render(scene, camera); 
};

...
</code></pre><p>Now, what it takes to rotate the the blue cube around the red one?<br>Just one line:</p><pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;>...
    scene.add(red_cube);
    // scene.add(blue_cube);
    red_cube.add(blue_cube);
...
</code></pre>">...
    scene.add(red_cube);
    <span class="hljs-comment">// scene.add(blue_cube);</span>
    red_cube.add(blue_cube);
...
</code></pre><p>which give us:</p><p><img src="doc/img/dependent_rotation.gif" alt=""></p><p>Thus, instead of adding the blue cube to the scene “directly”, we add it “indirectly” by adding it to the red one, thus creating a parent-child relation, where the red cube is the parent, while the blue one is a child, and all subsequent transformations on parent will influence its dependents.</p><p>Yeah, good to know, but how this could be useful in our case?</p><p>In one of our old <a href="https://forge.autodesk.com/cloud_and_mobile/2015/01/add-geometry-with-autodesk-view-data-api-by-threejs.html">posts</a>, and in <a href="https://forge.autodesk.com/blog/adding-custom-lines-forge-viewer-scene">a newer one</a> we illustrated how to add three.js objects to Viewer’s scene. </p><p>Now guess what happens if we add another object, not to the scene, but as a child to the first one.</p><p>Obviously the parent-child relation is working in the Viewer for the three.js objects, but how this can be useful?</p><p>Well, we cannot assign a component of our model to be a child of three.js object, but we can easily read the three.js transformation data and assign the needed ones to our model.</p><p>In other words, to rotate the SecondsArm component around the Pin component, we can do the following:</p><ol>
<li><p>create an empty three.js object and add it to the Viewer scene. Let us call it <em>pivot_seconds</em> object:</p>
<p> For debugging purposes we will assign it a geometry and a material, just to illustrate it’s position in our viewer, but in the end we can just create a <code>new THREE.Mesh()</code> to make it “invisible”<br> ```javascript</p>
<p> let seconds_pivot = new THREE.Mesh(</p>
<pre><code data-origin="<pre><code>                     new THREE.BoxGeometry(10, 10, 10),
                     new THREE.MeshBasicMaterial({ color: 0xff0000 }));
</code></pre>">                     new THREE.BoxGeometry(10, 10, 10),
                     new THREE.MeshBasicMaterial({ color: 0xff0000 }));
</code></pre></li></ol><pre><code data-origin="<pre><code>viewer.impl.scene.add(seconds_pivot);

```

![](./doc/img/added_pivot.gif)
</code></pre>">viewer.impl.scene.add(seconds_pivot);

```

![](./doc/img/added_pivot.gif)
</code></pre><ol>
<li><p>move the pivot_seconds object to same position as Pin component position:</p>
<p> For that, we will need to get the current pin position, which could be abstracted as:</p>
<pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;> function getFragmentWorldMatrixByNodeId(nodeId) {
     let result = {
         fragId: [],
         matrix: [],
     }
     tree.enumNodeFragments(nodeId, function (frag) {

         let fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);
         let matrix = new THREE.Matrix4();

         fragProxy.getWorldMatrix(matrix);

         result.fragId.push(frag);
         result.matrix.push(matrix);
     });
     return result;
 }

 //some nodes might contain several fragments, but in our case we know it has one fragment

 let pin_position = getFragmentWorldMatrixByNodeId(pin_Id).matrix[0].getPosition().clone();
 seconds_pivot.position.x = pin_position.x;
 seconds_pivot.position.y = pin_position.y;
 seconds_pivot.position.z = pin_position.z;
</code></pre>"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFragmentWorldMatrixByNodeId</span><span class="hljs-params">(nodeId)</span> </span>{
     <span class="hljs-keyword">let</span> result = {
         fragId: [],
         matrix: [],
     }
     tree.enumNodeFragments(nodeId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(frag)</span> </span>{

         <span class="hljs-keyword">let</span> fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);
         <span class="hljs-keyword">let</span> matrix = <span class="hljs-keyword">new</span> THREE.Matrix4();

         fragProxy.getWorldMatrix(matrix);

         result.fragId.push(frag);
         result.matrix.push(matrix);
     });
     <span class="hljs-keyword">return</span> result;
 }

 <span class="hljs-comment">//some nodes might contain several fragments, but in our case we know it has one fragment</span>

 <span class="hljs-keyword">let</span> pin_position = getFragmentWorldMatrixByNodeId(pin_Id).matrix[<span class="hljs-number">0</span>].getPosition().clone();
 seconds_pivot.position.x = pin_position.x;
 seconds_pivot.position.y = pin_position.y;
 seconds_pivot.position.z = pin_position.z;
</code></pre>
<p> And we have it exactly where we needed:</p>
<p> <img src="doc/img/moved_pivot.gif" alt=""> </p>
</li></ol><ol>
<li><p>add another empty three.js object and add it to the pivot_seconds object. Let us call it <em>seconds_helper</em>, as it helps us to get the needed position for the <em>SecondsArm</em>:</p>
<pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;> let seconds_helper = new THREE.Mesh(
                             new THREE.BoxGeometry(5, 5, 5),
                             new THREE.MeshBasicMaterial({ color: 0x0000ff }));
 let secondsArm_position = getFragmentWorldMatrixByNodeId(secondsArm_Id).matrix[0].getPosition().clone();
 seconds_helper.position.x = secondsArm_position.x;
 seconds_helper.position.y = secondsArm_position.y;
 seconds_helper.position.z = secondsArm_position.z;
</code></pre>"> <span class="hljs-keyword">let</span> seconds_helper = <span class="hljs-keyword">new</span> THREE.Mesh(
                             <span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>),
                             <span class="hljs-keyword">new</span> THREE.MeshBasicMaterial({ color: <span class="hljs-number">0x0000ff</span> }));
 <span class="hljs-keyword">let</span> secondsArm_position = getFragmentWorldMatrixByNodeId(secondsArm_Id).matrix[<span class="hljs-number">0</span>].getPosition().clone();
 seconds_helper.position.x = secondsArm_position.x;
 seconds_helper.position.y = secondsArm_position.y;
 seconds_helper.position.z = secondsArm_position.z;
</code></pre>
<p> Here comes the most important part:<br> If we add <em>seconds_helper</em> directly to the scene by calling <code>viewer.impl.scene.add(seconds_helper)</code>:</p>
<p> <img src="doc/img/03.direct.png" alt=""></p>
<p> by using a simple debugging piece of code:</p>
<pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;> console.log(&quot;Pin position = &quot; + JSON.stringify(seconds_pivot.position));
 console.log(&quot;SecondsArm position = &quot; + JSON.stringify(secondsArm_position));
 console.log(&quot;Helper position = &quot; + JSON.stringify(seconds_helper.position));
</code></pre>"> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Pin position = "</span> + <span class="hljs-built_in">JSON</span>.stringify(seconds_pivot.position));
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"SecondsArm position = "</span> + <span class="hljs-built_in">JSON</span>.stringify(secondsArm_position));
 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Helper position = "</span> + <span class="hljs-built_in">JSON</span>.stringify(seconds_helper.position));
</code></pre>
<p> we can investigate the positions:</p>
<pre><code data-origin="<pre><code> Pin position = {&quot;x&quot;:15.75,&quot;y&quot;:-11.25,&quot;z&quot;:-0.0030820071697235107}
 SecondsArm position = {&quot;x&quot;:19.25,&quot;y&quot;:7.5,&quot;z&quot;:0}
 Helper position = {&quot;x&quot;:19.25,&quot;y&quot;:7.5,&quot;z&quot;:0}
</code></pre>"> Pin position = {"x":15.75,"y":-11.25,"z":-0.0030820071697235107}
 SecondsArm position = {"x":19.25,"y":7.5,"z":0}
 Helper position = {"x":19.25,"y":7.5,"z":0}
</code></pre><p> Our helper will be at <em>SecondsArm</em> component’s position, but it wouldn’t be much of help.</p>
<p> On the other hand, if we add it as a child of the <em>seconds_pivot</em> , by calling <code>seconds_pivot.add(seconds_helper);</code> we end up with something different than expecting:</p>
<p> <img src="doc/img/added_helper.gif" alt=""></p>
</li></ol><pre><code data-origin="<pre><code>If we check the debug output, we get the same positions as before, but the catch is that in case of *seconds_helper*, that position is relative to is parent. To see its world position, the following debugging snippet will help:

```javascript
seconds_pivot.updateMatrixWorld();
var seconds_helper_wold_position = new THREE.Vector3();
seconds_helper.localToWorld(seconds_helper_wold_position);
console.log(&quot;Helper's World position = &quot; + JSON.stringify(seconds_helper_wold_position));
```

which give us the world position:
```
Helper's World position = {&quot;x&quot;:35,&quot;y&quot;:-3.75,&quot;z&quot;:-0.0030820071697235107}
```

As you can see, that's explains why the blue box is not at expected coordinates.
From this point there are several ways to approach this, but the one that I'm using is through creation of :

Let us look at the offset - the distance between the needed component and the wanted pivot, which in our case would be: 

&amp;gt;|          | Pin position  | SecondArm position | Offset  |
&amp;gt;|----------|:-------------:|-------------------:|--------:|
&amp;gt;| X        |  15.75        |   19.25            | 3.5     |
&amp;gt;| Y        |  -11.25       |   7.5              | 18.75   |
&amp;gt;| Z        | ~ 0           |    ~ 0             |~ 0      |


Knowing this offset, the position of our *seconds_helper* would be:

``` - [SecondArm position] + [abs(Offset)]```

Why so complicated?

The thing is that when you are assigning a new position to a fragment proxy, you are not assigning the World position, but a local one.

To better illustrate this as a side note, let us assign 10 units to fragments of the &quot;Holder&quot; component and see how it affects the World position:

![](./doc/img/04.holder.png)

By calling the scary construction:
```javascript
let Holder_Id = findNodeIdbyName('Holder');
console.log(JSON.stringify(getFragmentWorldMatrixByNodeId(Holder_Id).matrix[0].getPosition()));
```
we get:
```
{&quot;x&quot;:0,&quot;y&quot;:81.74999237060547,&quot;z&quot;:0}
```
Now using the already mentioned approach and assign 10 to fragment's Y position:

```javascript
let secondsArm_Id = findNodeIdbyName('SecondsArm');
let tree = viewer.model.getData().instanceTree;

tree.enumNodeFragments(Holder_Id, function (frag) {
    var fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);
    fragProxy.getAnimTransform();
    fragProxy.position.y = 10
    fragProxy.updateAnimTransform();
});

viewer.impl.sceneUpdated(true);
```
we moved the component up:

![](./doc/img/04.holder_01.png)

and it's world position now changed to 
```
{&quot;x&quot;:0,&quot;y&quot;:91.74999237060547,&quot;z&quot;:0}
```

Thus, the fragment proxy's transformations are just &quot;portals&quot; to modify the component's world position and not to set it (this is whay it is called a proxy after all).


Now, back to our &quot;offset thing&quot;. As I said, knowing this offset, the position of our *seconds_helper* would be:

``` - [SecondArm position] + [abs(Offset)]```

or 
```javascript
seconds_helper.position.x = - secondsArm_position.x + Math.abs(secondsArm_position.x - seconds_pivot.position.x);
seconds_helper.position.y = - secondsArm_position.y + Math.abs(secondsArm_position.y - seconds_pivot.position.y);
seconds_helper.position.z = - secondsArm_position.z + Math.abs(secondsArm_position.z - seconds_pivot.position.z);
```

which in our debug output will give us
```
PinPivot position = {&quot;x&quot;:15.75,&quot;y&quot;:-11.25,&quot;z&quot;:-0.0030820071697235107}
SecondsArm component position = {&quot;x&quot;:19.25,&quot;y&quot;:7.5,&quot;z&quot;:0}
Helper position = {&quot;x&quot;:-15.75,&quot;y&quot;:11.25,&quot;z&quot;:0.0030820071697235107}
```

Why this offset is need, will be explained in the second part of this blog post, where we will deal with complex transformation, but for now just believe me that these are the needed operations.
</code></pre>">If we check the debug output, we get the same positions as before, but the catch is that in case of *seconds_helper*, that position is relative to is parent. To see its world position, the following debugging snippet will help:

```javascript
seconds_pivot.updateMatrixWorld();
var seconds_helper_wold_position = new THREE.Vector3();
seconds_helper.localToWorld(seconds_helper_wold_position);
console.log("Helper's World position = " + JSON.stringify(seconds_helper_wold_position));
```

which give us the world position:
```
Helper's World position = {"x":35,"y":-3.75,"z":-0.0030820071697235107}
```

As you can see, that's explains why the blue box is not at expected coordinates.
From this point there are several ways to approach this, but the one that I'm using is through creation of :

Let us look at the offset - the distance between the needed component and the wanted pivot, which in our case would be: 

&gt;|          | Pin position  | SecondArm position | Offset  |
&gt;|----------|:-------------:|-------------------:|--------:|
&gt;| X        |  15.75        |   19.25            | 3.5     |
&gt;| Y        |  -11.25       |   7.5              | 18.75   |
&gt;| Z        | ~ 0           |    ~ 0             |~ 0      |


Knowing this offset, the position of our *seconds_helper* would be:

``` - [SecondArm position] + [abs(Offset)]```

Why so complicated?

The thing is that when you are assigning a new position to a fragment proxy, you are not assigning the World position, but a local one.

To better illustrate this as a side note, let us assign 10 units to fragments of the "Holder" component and see how it affects the World position:

![](./doc/img/04.holder.png)

By calling the scary construction:
```javascript
let Holder_Id = findNodeIdbyName('Holder');
console.log(JSON.stringify(getFragmentWorldMatrixByNodeId(Holder_Id).matrix[0].getPosition()));
```
we get:
```
{"x":0,"y":81.74999237060547,"z":0}
```
Now using the already mentioned approach and assign 10 to fragment's Y position:

```javascript
let secondsArm_Id = findNodeIdbyName('SecondsArm');
let tree = viewer.model.getData().instanceTree;

tree.enumNodeFragments(Holder_Id, function (frag) {
    var fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);
    fragProxy.getAnimTransform();
    fragProxy.position.y = 10
    fragProxy.updateAnimTransform();
});

viewer.impl.sceneUpdated(true);
```
we moved the component up:

![](./doc/img/04.holder_01.png)

and it's world position now changed to 
```
{"x":0,"y":91.74999237060547,"z":0}
```

Thus, the fragment proxy's transformations are just "portals" to modify the component's world position and not to set it (this is whay it is called a proxy after all).


Now, back to our "offset thing". As I said, knowing this offset, the position of our *seconds_helper* would be:

``` - [SecondArm position] + [abs(Offset)]```

or 
```javascript
seconds_helper.position.x = - secondsArm_position.x + Math.abs(secondsArm_position.x - seconds_pivot.position.x);
seconds_helper.position.y = - secondsArm_position.y + Math.abs(secondsArm_position.y - seconds_pivot.position.y);
seconds_helper.position.z = - secondsArm_position.z + Math.abs(secondsArm_position.z - seconds_pivot.position.z);
```

which in our debug output will give us
```
PinPivot position = {"x":15.75,"y":-11.25,"z":-0.0030820071697235107}
SecondsArm component position = {"x":19.25,"y":7.5,"z":0}
Helper position = {"x":-15.75,"y":11.25,"z":0.0030820071697235107}
```

Why this offset is need, will be explained in the second part of this blog post, where we will deal with complex transformation, but for now just believe me that these are the needed operations.
</code></pre><ol>
<li><p>apply <em>seconds_helper</em> transforms <em>SecondsArm</em> component’s transform:</p>
<p> This is done by decomposing the <em>seconds_helper</em> transformation into position, scale and rotation(quaternion) and could be stated as a following function:</p>
<p> easily achieved by steps that could be embedded in a following :</p>
<pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;> function assignTransformations(refererence_dummy, nodeId) {
     refererence_dummy.updateMatrixWorld();
     var position = new THREE.Vector3();
     var rotation = new THREE.Quaternion();
     var scale = new THREE.Vector3();
     refererence_dummy.matrixWorld.decompose(position, rotation, scale);

     tree.enumNodeFragments(nodeId, function (frag) {
         var fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);
         fragProxy.getAnimTransform();
         fragProxy.position = position;
         fragProxy.quaternion = rotation;
         fragProxy.updateAnimTransform();
     });
 }
</code></pre>"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assignTransformations</span><span class="hljs-params">(refererence_dummy, nodeId)</span> </span>{
     refererence_dummy.updateMatrixWorld();
     <span class="hljs-keyword">var</span> position = <span class="hljs-keyword">new</span> THREE.Vector3();
     <span class="hljs-keyword">var</span> rotation = <span class="hljs-keyword">new</span> THREE.Quaternion();
     <span class="hljs-keyword">var</span> scale = <span class="hljs-keyword">new</span> THREE.Vector3();
     refererence_dummy.matrixWorld.decompose(position, rotation, scale);

     tree.enumNodeFragments(nodeId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(frag)</span> </span>{
         <span class="hljs-keyword">var</span> fragProxy = viewer.impl.getFragmentProxy(viewer.model, frag);
         fragProxy.getAnimTransform();
         fragProxy.position = position;
         fragProxy.quaternion = rotation;
         fragProxy.updateAnimTransform();
     });
 }
</code></pre>
<p> This is the </p>
</li></ol><pre><code data-origin="<pre><code>Thus, as we mentioned in the previous step, if we have
```
SecondsArm component position = {&quot;x&quot;:19.25,&quot;y&quot;:7.5,&quot;z&quot;:0}
```
and we assign to fragment proxy the position of the helper
```
Helper position = {&quot;x&quot;:-15.75,&quot;y&quot;:11.25,&quot;z&quot;:0.0030820071697235107}
```
the resulted position 
```
SecondsArm component new position = {&quot;x&quot;:3.5,&quot;y&quot;:18.75,&quot;z&quot;:0.0030820071697235107}
```
</code></pre>">Thus, as we mentioned in the previous step, if we have
```
SecondsArm component position = {"x":19.25,"y":7.5,"z":0}
```
and we assign to fragment proxy the position of the helper
```
Helper position = {"x":-15.75,"y":11.25,"z":0.0030820071697235107}
```
the resulted position 
```
SecondsArm component new position = {"x":3.5,"y":18.75,"z":0.0030820071697235107}
```
</code></pre><p>After looking at all this, many of you might think that those matrix things might not be so scary after all and all this method is quite complicated, thus making this blog useless if not to say more.</p><p>These thoughts will dissappear very fast when you realize that after a small setup (whose logic I tried to explain above), further component manipulations like rotation around another component, becomes super easy.</p><p>Thus in our case, the only thing we need now, to have the <em>SecondsArm</em> component rotate around the Pin component is to call: </p><pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;>    seconds_pivot.rotation.x = some_value;
    assignTransformations(seconds_helper, secondsArm_Id);
    viewer.impl.sceneUpdated();
</code></pre>">    seconds_pivot.rotation.x = some_value;
    assignTransformations(seconds_helper, secondsArm_Id);
    viewer.impl.sceneUpdated();
</code></pre><p>which can be abstracted further to a single function, but these are already just technicalities.</p><p>Back to our clock thing, having setup like this:</p><pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;>/* ====================== SECONDS ================= */
let seconds_pivot = new THREE.Mesh();
let pin_position = getFragmentWorldMatrixByNodeId(pin_Id).matrix[0].getPosition().clone();
seconds_pivot.position.x = pin_position.x;
seconds_pivot.position.y = pin_position.y;
seconds_pivot.position.z = pin_position.z;

let seconds_helper = new THREE.Mesh();
let secondsArm_position = getFragmentWorldMatrixByNodeId(secondsArm_Id).matrix[0].getPosition().clone();
seconds_helper.position.x = - secondsArm_position.x + Math.abs(secondsArm_position.x - seconds_pivot.position.x);
seconds_helper.position.y = - secondsArm_position.y + Math.abs(secondsArm_position.y - seconds_pivot.position.y);
seconds_helper.position.z = - secondsArm_position.z + Math.abs(secondsArm_position.z - seconds_pivot.position.z);

viewer.impl.scene.add(seconds_pivot);
seconds_pivot.add(seconds_helper);
</code></pre>"><span class="hljs-comment">/* ====================== SECONDS ================= */</span>
<span class="hljs-keyword">let</span> seconds_pivot = <span class="hljs-keyword">new</span> THREE.Mesh();
<span class="hljs-keyword">let</span> pin_position = getFragmentWorldMatrixByNodeId(pin_Id).matrix[<span class="hljs-number">0</span>].getPosition().clone();
seconds_pivot.position.x = pin_position.x;
seconds_pivot.position.y = pin_position.y;
seconds_pivot.position.z = pin_position.z;

<span class="hljs-keyword">let</span> seconds_helper = <span class="hljs-keyword">new</span> THREE.Mesh();
<span class="hljs-keyword">let</span> secondsArm_position = getFragmentWorldMatrixByNodeId(secondsArm_Id).matrix[<span class="hljs-number">0</span>].getPosition().clone();
seconds_helper.position.x = - secondsArm_position.x + <span class="hljs-built_in">Math</span>.abs(secondsArm_position.x - seconds_pivot.position.x);
seconds_helper.position.y = - secondsArm_position.y + <span class="hljs-built_in">Math</span>.abs(secondsArm_position.y - seconds_pivot.position.y);
seconds_helper.position.z = - secondsArm_position.z + <span class="hljs-built_in">Math</span>.abs(secondsArm_position.z - seconds_pivot.position.z);

viewer.impl.scene.add(seconds_pivot);
seconds_pivot.add(seconds_helper);
</code></pre><p>It is very easy to make the SecondsArm component show the almost realtime seconds:</p><pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;>setInterval(function () {
    var timing = new Date();

    seconds_pivot.rotation.x = -1 * timing.getSeconds() * 2 * Math.PI / 60;
    assignTransformations(seconds_helper, secondsArm_Id);
    viewer.impl.sceneUpdated();

}, 1000);
</code></pre>">setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> timing = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();

    seconds_pivot.rotation.x = -<span class="hljs-number">1</span> * timing.getSeconds() * <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">60</span>;
    assignTransformations(seconds_helper, secondsArm_Id);
    viewer.impl.sceneUpdated();

}, <span class="hljs-number">1000</span>);
</code></pre><p>That’s it!<br>By repeating same steps for MinuteArm and HourArm, you will have a model of a desk clock showing a real time, as illustrated <a href="http://sample-collection.s3-website-us-east-1.amazonaws.com/WoodenWatch.html">here</a>.</p><p>Now you should have the necessary ingredients to make you models even more appealing, by embedding small animations or functionality illustrations. At least a clock shop is ready to go. </p><p>At this step, some of you may still look skeptical at this approach and wonder what it is a big deal about it, as it is not much easier than just creating a matrix out of 3 matrices. Don’t worry, you are perfectly right … at some extent … that till you have to deal with a more complex chained transformations and to illustrate this, I invite you to reinforce our knowledge on a more complex model in second part <a href="">Chained transforms</a> post.</p><h1 id="know-how:-complex-component-transformations-in-viewer---part-2-(hierarchical-transformations)"><a name="know-how:-complex-component-transformations-in-viewer---part-2-(hierarchical-transformations)" href="#know-how:-complex-component-transformations-in-viewer---part-2-(hierarchical-transformations)"></a>Know-how: Complex component transformations in Viewer - Part 2 (Hierarchical Transformations)</h1><p>In <a href="https://forge.autodesk.com/blog/know-how-complex-component-transformations-viewer-part-1-basics">part 1</a> of this series, we discussed about basics of component transformations using three.js, while in this part we will see how the presented approach can be applied to a more complex hierarchical transformations.</p><p>To illustrate this, I will use a fairly old, yet useful simple model of a 4DOF robotic arm, that in my opinion is an excellent example of how model’s components could hierarchically depend on another’s position creating a dependecy link (<a href="https://en.wikipedia.org/wiki/Kinematic_chain">kinematic chain</a>).</p><p><img src="doc/img/08.RoboInital.png" alt=""></p><p>As all other examples in this serie, the code abstraction will be reduced to the minimum for sake of simplicity and since, what you see is what you have, it is also open for different “on fly” manipulations and experimentations. </p><p>Moreover, this model contains some design errors (positional missalignments), so the reduced code abstraction will also allow me to demonstrate (along the way) how these kind of “mistakes” can be easily corrected “on the fly”, a minor thing that might be critical in situations when you don’t have access to the “original” model and a very important use case to keep in mind if you are condidering abstracting all this code into a simple library or a framework.</p><p>In <a href="https://forge.autodesk.com/blog/know-how-complex-component-transformations-viewer-part-1-basics">previous part</a>, we had a simple desk clock model and we managed to implement basic rotations of the seconds, minutes and hour arms by having 3 independent pivots.</p><p>This model, on the other hand, contains 7 components needed to be transformed and the transformation of some components is influenced and might influence others, forming a sort of dependency tree:</p><pre><code data-origin="<pre><code>A
|-B
  |-C
  |-D
    |-E
    |-F
      |-G
</code></pre>">A
|-B
  |-C
  |-D
    |-E
    |-F
      |-G
</code></pre><p>In other words, if (for example) component D is transformed (in our case rotated around C), then it should affect the position/orientation of its depencies E and F. Obiously, any transformation propagated to F is also propagated to its dependents (in this case just G).</p><p><img src="doc/img/06.RobotComponentDescription.png" alt=""></p><p>In this model we 4 axis, so we have to rely on 4 pivots that will be positioned at A, C, E and G.<br>After <a href="">previous post</a> the start should be simple, create a pivot at position of A component and a helper (taking into consideration the offset) which will be responsible for adjusting the “linked” B component:</p><pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;>let Pivot_BaseRod = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), 
                                   new THREE.MeshBasicMaterial({ color: 0xff0000 }));
let Position_BaseRod = getFragmentWorldMatrixByNodeId(ID_BaseRod).matrix[0].getPosition().clone();
Pivot_BaseRod.position.x = Position_BaseRod.x;
Pivot_BaseRod.position.y = Position_BaseRod.y;
Pivot_BaseRod.position.z = Position_BaseRod.z;
viewer.impl.scene.add(Pivot_BaseRod);


let Helper_LowerArmBody = new THREE.Mesh();
let Position_LowerArmBody = getFragmentWorldMatrixByNodeId(ID_LowerArmBody).matrix[0].getPosition().clone();
Helper_LowerArmBody.position.x = - Position_LowerArmBody.x + Math.abs(Position_LowerArmBody.x - Pivot_BaseRod.position.x);
Helper_LowerArmBody.position.y = - Position_LowerArmBody.y + Math.abs(Position_LowerArmBody.y - Pivot_BaseRod.position.y);
Helper_LowerArmBody.position.z = - Position_LowerArmBody.z + Math.abs(Position_LowerArmBody.z - Pivot_BaseRod.position.z);
Pivot_BaseRod.add(Helper_LowerArmBody);
</code></pre>"><span class="hljs-keyword">let</span> Pivot_BaseRod = <span class="hljs-keyword">new</span> THREE.Mesh(<span class="hljs-keyword">new</span> THREE.BoxGeometry(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>), 
                                   <span class="hljs-keyword">new</span> THREE.MeshBasicMaterial({ color: <span class="hljs-number">0xff0000</span> }));
<span class="hljs-keyword">let</span> Position_BaseRod = getFragmentWorldMatrixByNodeId(ID_BaseRod).matrix[<span class="hljs-number">0</span>].getPosition().clone();
Pivot_BaseRod.position.x = Position_BaseRod.x;
Pivot_BaseRod.position.y = Position_BaseRod.y;
Pivot_BaseRod.position.z = Position_BaseRod.z;
viewer.impl.scene.add(Pivot_BaseRod);


<span class="hljs-keyword">let</span> Helper_LowerArmBody = <span class="hljs-keyword">new</span> THREE.Mesh();
<span class="hljs-keyword">let</span> Position_LowerArmBody = getFragmentWorldMatrixByNodeId(ID_LowerArmBody).matrix[<span class="hljs-number">0</span>].getPosition().clone();
Helper_LowerArmBody.position.x = - Position_LowerArmBody.x + <span class="hljs-built_in">Math</span>.abs(Position_LowerArmBody.x - Pivot_BaseRod.position.x);
Helper_LowerArmBody.position.y = - Position_LowerArmBody.y + <span class="hljs-built_in">Math</span>.abs(Position_LowerArmBody.y - Pivot_BaseRod.position.y);
Helper_LowerArmBody.position.z = - Position_LowerArmBody.z + <span class="hljs-built_in">Math</span>.abs(Position_LowerArmBody.z - Pivot_BaseRod.position.z);
Pivot_BaseRod.add(Helper_LowerArmBody);
</code></pre><p>Giving the expected (for those who looked at the previous article) positions:</p><p><img src="doc/img/05.RobotPivot_01.png" alt=""></p><p>However, what about the subsequent components?</p><p>The overall algorithm here is fairly simple, for each axis, create a pivot and for each component, create a helper linked to the needed axis.</p><p>However, there is one thing we have to keep in mind and it has to do with offset we briefly mentioned in the <a href="">previous part</a>.</p><p>The offset for the first handler is simple, as it takes into consideration just the pivot position, but in case of a handler depending on a pivot that depends on another pivot (as in this case D depends on C, which dependes on A), the sitaution complicates, but not very much:</p><pre class="javascript hljs"><code class="javascript" data-origin="<pre><code class=&quot;javascript&quot;>let Pivot_LowerRodBody = new THREE.Mesh();
let Position_LowerRodBody = getFragmentWorldMatrixByNodeId(ID_LowerRodBody).matrix[0].getPosition().clone();

Pivot_LowerRodBody.position.x = Position_LowerRodBody.x - Pivot_BaseRod.position.x;
Pivot_LowerRodBody.position.y = Position_LowerRodBody.y - Pivot_BaseRod.position.y;
Pivot_LowerRodBody.position.z = Position_LowerRodBody.z - Pivot_BaseRod.position.z;
Pivot_BaseRod.add(Pivot_LowerRodBody);

let Helper_LowerRodBody = new THREE.Mesh();
Helper_LowerRodBody.position.x = - Position_LowerRodBody.x + Math.abs(Position_LowerRodBody.x - Pivot_LowerRodBody.position.x - Pivot_BaseRod.position.x);
Helper_LowerRodBody.position.y = - Position_LowerRodBody.y + Math.abs(Position_LowerRodBody.y - Pivot_LowerRodBody.position.y - Pivot_BaseRod.position.y);
Helper_LowerRodBody.position.z = - Position_LowerRodBody.z + Math.abs(Position_LowerRodBody.z - Pivot_LowerRodBody.position.z - Pivot_BaseRod.position.z);
Pivot_LowerRodBody.add(Helper_LowerRodBody);
</code></pre>"><span class="hljs-keyword">let</span> Pivot_LowerRodBody = <span class="hljs-keyword">new</span> THREE.Mesh();
<span class="hljs-keyword">let</span> Position_LowerRodBody = getFragmentWorldMatrixByNodeId(ID_LowerRodBody).matrix[<span class="hljs-number">0</span>].getPosition().clone();

Pivot_LowerRodBody.position.x = Position_LowerRodBody.x - Pivot_BaseRod.position.x;
Pivot_LowerRodBody.position.y = Position_LowerRodBody.y - Pivot_BaseRod.position.y;
Pivot_LowerRodBody.position.z = Position_LowerRodBody.z - Pivot_BaseRod.position.z;
Pivot_BaseRod.add(Pivot_LowerRodBody);

<span class="hljs-keyword">let</span> Helper_LowerRodBody = <span class="hljs-keyword">new</span> THREE.Mesh();
Helper_LowerRodBody.position.x = - Position_LowerRodBody.x + <span class="hljs-built_in">Math</span>.abs(Position_LowerRodBody.x - Pivot_LowerRodBody.position.x - Pivot_BaseRod.position.x);
Helper_LowerRodBody.position.y = - Position_LowerRodBody.y + <span class="hljs-built_in">Math</span>.abs(Position_LowerRodBody.y - Pivot_LowerRodBody.position.y - Pivot_BaseRod.position.y);
Helper_LowerRodBody.position.z = - Position_LowerRodBody.z + <span class="hljs-built_in">Math</span>.abs(Position_LowerRodBody.z - Pivot_LowerRodBody.position.z - Pivot_BaseRod.position.z);
Pivot_LowerRodBody.add(Helper_LowerRodBody);
</code></pre><p>As you can see, here we have two relatively new things:</p><ul>
<li>When creating a pivot that depends on another pivot (pivot child of the another pivot), we have to place it at rotation point, but keep into consideration that it’s position is related to parent and not the World, so we have to substract the parent’s position.<br>For example for pivot corresponding to component E, we have to take into consideration the position of component E, pivot coresponding to C and the one corresponding to A:<br>:<br>```javascript<br>…</li></ul><p>let Pivot_UpperRodBody = new THREE.Mesh();<br>  let Position_UpperRodBody = getFragmentWorldMatrixByNodeId(ID_UpperRodBody).matrix[0].getPosition().clone();</p><p>  Pivot_UpperRodBody.position.x = Position_UpperRodBody.x - Pivot_LowerRodBody.position.x - Pivot_BaseRod.position.x;<br>  Pivot_UpperRodBody.position.y = Position_UpperRodBody.y - Pivot_LowerRodBody.position.y - Pivot_BaseRod.position.y;<br>  Pivot_UpperRodBody.position.z = Position_UpperRodBody.z - Pivot_LowerRodBody.position.z - Pivot_BaseRod.position.z;<br>  Pivot_LowerRodBody.add(Pivot_UpperRodBody);<br>…</p><pre><code data-origin="<pre><code>
- Another thing is related to helpers. If for direct helpers (those depending on root pivot), we took into consideration just the offset from pivot position, then now we have to &quot;accumulate&quot; these offsets:
```javascript
...

let Helper_UpperRodBody = new THREE.Mesh();

Helper_UpperRodBody.position.x = - Position_UpperRodBody.x + Math.abs(Position_UpperRodBody.x - Pivot_UpperRodBody.position.x - Pivot_LowerRodBody.position.x - Pivot_BaseRod.position.x);
Helper_UpperRodBody.position.y = - Position_UpperRodBody.y + Math.abs(Position_UpperRodBody.y - Pivot_UpperRodBody.position.y - Pivot_LowerRodBody.position.y - Pivot_BaseRod.position.y);
Helper_UpperRodBody.position.z = - Position_UpperRodBody.z + Math.abs(Position_UpperRodBody.z - Pivot_UpperRodBody.position.z - Pivot_LowerRodBody.position.z - Pivot_BaseRod.position.z);
Pivot_UpperRodBody.add(Helper_UpperRodBody);

...
</code></pre>">
- Another thing is related to helpers. If for direct helpers (those depending on root pivot), we took into consideration just the offset from pivot position, then now we have to "accumulate" these offsets:
```javascript
...

let Helper_UpperRodBody = new THREE.Mesh();

Helper_UpperRodBody.position.x = - Position_UpperRodBody.x + Math.abs(Position_UpperRodBody.x - Pivot_UpperRodBody.position.x - Pivot_LowerRodBody.position.x - Pivot_BaseRod.position.x);
Helper_UpperRodBody.position.y = - Position_UpperRodBody.y + Math.abs(Position_UpperRodBody.y - Pivot_UpperRodBody.position.y - Pivot_LowerRodBody.position.y - Pivot_BaseRod.position.y);
Helper_UpperRodBody.position.z = - Position_UpperRodBody.z + Math.abs(Position_UpperRodBody.z - Pivot_UpperRodBody.position.z - Pivot_LowerRodBody.position.z - Pivot_BaseRod.position.z);
Pivot_UpperRodBody.add(Helper_UpperRodBody);

...
</code></pre><p>By adding some controls (in my case using the simple <a href="">dat.gui.js</a> library) we end up with a “controllable” model that could serve as a perfect illustration for a simple interactive robot, ready to impress.</p><p><img src="doc/img/07.RobotMain.png" alt=""></p><p>If you want to play with the final result and see how smoothly it behaves, you can find it [here]<a href="http://sample-collection.s3-website-us-east-1.amazonaws.com/DummyRobot.html">http://sample-collection.s3-website-us-east-1.amazonaws.com/DummyRobot.html</a>).</p><p>This ends this second part, but not our quest for mastering the transformations in Viewer using three.js.<br>In the <a href="">next and final part</a> we are going to reinforce this approach by exploring a even more complex use-case, where some of the “inherited” (coming from indirect pivots) transformations has to be selectively ignored. Why you would need that? Check this <a href="http://sample-collection.s3-website-us-east-1.amazonaws.com/GiroWatch.html">example</a> upon which all will be explained.</p><h1 id="know-how:-complex-component-transformations-in-viewer---part-3-(selective-transformations)"><a name="know-how:-complex-component-transformations-in-viewer---part-3-(selective-transformations)" href="#know-how:-complex-component-transformations-in-viewer---part-3-(selective-transformations)"></a>Know-how: Complex component transformations in Viewer - Part 3 (Selective Transformations)</h1><p><img src="doc/img/08.GiroMain.png" alt=""></p><p>In <a href="">previous article</a> I introduced an indirect way of transforming components, that allows you to avoid dealing with affine transformations directly and rely on computation results “generated” by the three.js parent-child relation.</p><p>To reinforce this approach and illustrate its benefits in a more complex use case, in what follows, I invite you to join me in my endeavor of bringing some interaction to a bit more complex model, that I called GiroWatch.</p><p>Thus, our requirements are the following:</p><ol>
<li><p>implement hour, minute, second rotations, to reflect current time.</p>
</li><li><p>implement a manipulator (slider) that a user can interact with, to change the frame rotations.</p>
</li></ol><p>The first point is quite simple, as we already achieved similar thing in <a href="">previous article</a>, but we will return to this requirement toward the end, as the Pin component is now not independent as in previous example, but a child of ClockBody.</p><p>Thus, let us start by mapping the “imaginative” hierarchical tree:</p><pre><code data-origin="<pre><code>[Center]
- [MainFrame]
    - [SecondFrame]
        - [ThirdFrame]
        - [ClockBody]
            - [Glass]
            - [HourDial]
            - [Pin]
                - [SecondsArm]
                - [MinuteArm]
                - [HourArm]
</code></pre>">[Center]
- [MainFrame]
    - [SecondFrame]
        - [ThirdFrame]
        - [ClockBody]
            - [Glass]
            - [HourDial]
            - [Pin]
                - [SecondsArm]
                - [MinuteArm]
                - [HourArm]
</code></pre><p>I came up with a “giroscopic” thing on purpose, as it’s magic nature cannot be always resolved by a streightforward hierarchy - some parent rotations must be propagated, while some of them should be ignored. This becomes quite confusing when using the matrix transformations, while in our case it will be dealt fairly easy, through creation of a proxy object that will compensate the unwanted transformations.</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
